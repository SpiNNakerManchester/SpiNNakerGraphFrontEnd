import nengo
from spinnaker_graph_front_end.examples.nengo.filters.linear_filter import \
    LinearFilter
from spinnaker_graph_front_end.examples.nengo.filters.low_pass_filter import \
    LowPassFilter
from spinnaker_graph_front_end.examples.nengo.filters.none_filter import \
    NoneFilter


class FilterAndRoutingRegionGenerator(object):

    def __init__(self):
        self._supported_filter_types = {
            None: NoneFilter,
            nengo.synapses.Lowpass: LowPassFilter,
            nengo.synapses.LinearFilter: LinearFilter,
        }

    def generate_filter_and_filter_routing_regions(
            self, spec, machine_graph, filter_region_id,
            filter_routing_region_id,
            minimise=False, filter_routing_tag="filter_routing",
            index_field="index", width=None):
        filters, signal_routes = self._make_filters(
            machine_graph, minimise=minimise, width=width)

        # Create the regions
        filter_region = FilterRegion(filters, dt)
        routing_region = FilterRoutingRegion(signal_routes, filter_routing_tag,
                                             index_field)

    def _make_filters(self, machine_graph, minimise, width):
        """Create a list of filters and keyspace routes from the given
        signals and connections.

        Parameters
        ----------
        specs : [ReceptionSpec, ...]
            List of reception specs (as generated by `get_signals_to`) to build the
            filter regions for.

        Other Parameters
        ----------------
        minimise : bool
            It is possible to reduce the amount of memory and computation required
            to simulate filters by combining equivalent filters together.  If
            minimise is `True` then this is done, otherwise not.
        """
        # Create new lists of filters and the routing entries
        filters = list()
        signal_routes = list()

        # Add signals and connections to lists
        return add_filters(filters, signal_routes, specs, minimise, width)

    def _add_filters(self, filters, signal_routes, machine_graph,
                     minimise=False, width=None):
        """Add signals and connections to existing lists
        of filters and keyspace routes

        Parameters
        ----------
        signals_and_connections : {Signal: [Connection, ...], ...}
            Map of signals to the connections they represent.

        Other Parameters
        ----------------
        minimise : bool
            It is possible to reduce the amount of memory and computation required
            to simulate filters by combining equivalent filters together.  If
            minimise is `True` then this is done, otherwise not.
        """
        for signal, reception_params in specs:
            # Make the filter
            f_type = type(reception_params.filter)
            f = FilterRegion.supported_filter_types[f_type].from_parameters(
                signal, reception_params, width=width
            )

            # Store the filter and add the route
            for index, g in enumerate(filters):
                if f == g and minimise:
                    break
            else:
                index = len(filters)
                filters.append(f)

            signal_routes.append((signal, index))

        return filters, signal_routes
